# 组件化开发

我们前面学习了Vue组件的三大组成部分，其中每一部分都有相关的注意点：

- 结构
  - 只能有一个根元素
- 样式
  - 我们写在组件内部的样式，默认是全局样式
- 逻辑
  - el是根实例独有的属性
  - data在组件里是一个函数



## 组件的样式冲突

默认情况：写在组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。

- 全局样式：默认组件中的样式会作用到全局
- 局部样式，可以给组件加上**scoped**属性，*可以让样式只作用于当前组件*

语法：

```vue
<style scoped>
</style>
```

案例：

- 在components 文件夹中新建两个组件，然后注册在App.vue根组件中。

```vue
<!--组件BaseOne-->
<template>
    <div>BaseOne</div>
</template>
<script></script>
<style>
    div {
        border: 3px solid blue;
        margin: 30px;
    }
</style>


<!--组件BaseTwo-->
<template>
    <div>BaseTwo</div>
</template>
<script></script>
<style></style>


<!--App.vue-->
<template>
    <div class="app">
        <BaseOne></BaseOne>
        <BaseTwo></BaseTwo>
    </div>
</template>
<script>
// 导入组件，注意大驼峰命名
import BaseOne from './components/BaseOne.vue'
import BaseTwo from './components/BaseTwo.vue'
export default {
    // 注册局部组件，这种注册方式，只能在这个注册的组件内部使用
    components:{
        BaseOne,
        BaseTwo
    }
}
</script>
<style></style>
```

可以看到，我们上面两个普通组件，我在BaseOne组件中对div元素设置了样式，当我们注册并使用之后，效果如下：

![image-20240229212218768](img/12.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%912//image-20240229212218768.png)

我们在BaseOne中对div设置了样式，但是运行之后，BaseTwo组件中的div也渲染了这个样式。这就说明我们定义在组件中的样式默认是全局样式。

如果我们想只针对单个组件生效，我们可以给style标签添加scoped属性。

```vue
<!--组件BaseOne-->
<template>
    <div>BaseOne</div>
</template>
<script></script>
<style scoped>
    div {
        border: 3px solid blue;
        margin: 30px;
    }
</style>
```

重新运行之后的效果：

![image-20240229212625762](img/12.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%912//image-20240229212625762.png)

## data是一个函数

一个组件的data选项必须是一个函数。

**是为了保证每个组件实例，维护独立的一份数据对象。**

每次创建新的组件实例，都会执行一次data函数，得到一个新对象。

```vue
<script>
export default {
    data() {
        return {
            count:100
        }
    }
}
</script>
```



## 组件通信

组件通信，就是指组件与组件之间的数据传递。

组件的数据是独立的，无法直接访问其他组件的数据。如果想要使用其他组件的数据。就需要组件通信。

![image-20240318213357673](img/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81%E5%8F%8A%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1//image-20240318213357673.png)

组件之间的关系通常分为两种

- 父子关系，上面的案例中，A组件包含B、C组件，所以A组件和B组件就是父子关系。A组件和C组件也是父子关系。
- 非父子关系，上面的案例中，B、C就是非父子关系。



### 父子关系

- 父组件通过`props`将数据传递给子组件（父传子）
- 子组件利用`$emit`通知父组件修改更新（子传父）



#### 父传子

1. 父组件定义数据
2. 将要传递的数据动态的绑定在子组件实例上，绑定的属性名要和子组件接收的属性名一致
3. 在子组件中使用props接收数据，如果有多个传值，在数组中写多个即可
4. 使用

![image-20240318220642120](img/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81%E5%8F%8A%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1//image-20240318220642120.png)

![image-20240318220403988](img/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81%E5%8F%8A%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1//image-20240318220403988.png)

#### 子传父

1. 在子组件中通过`$emit`来通知父组件
2. 在父组件中，在子组件实例上，监听子组件对父组件的通知事件，监听名要一致
3. 对监听的事件提供处理函数，可以使用形参来接收子组件传递过来的数据

![image-20240318221525257](img/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81%E5%8F%8A%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1//image-20240318221525257.png)



#### prop校验

prop定义：组件上注册的一些自定义属性

prop作用：向子组件传递数据

prop特点：可以传递任意数量、任意类型的数据

父组件可以传递数据给到子组件，子组件也可以对父组件传递的参数进行校验。Vue为我们提供了prop校验的方式，可以为prop指定验证要求，不符合条件的，控制台会有报错提示。

Vue为我们提供了以下几个功能来操作prop

- 类型校验
- 非空校验
- 默认值
- 自定义校验

其中类型校验可以简写，语法：

```json
props:{
   校验的属性名:类型,
},
```

```json
props:{
    校验的属性名:{
        type:类型, // 类型
        required:true, // 是否必填
        default: 默认值, // 默认值
        validator (value) {
            // 自定义校验逻辑
          return 是否通过校验
        }
    }
},
```

![image-20240328175541476](img/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81%E5%8F%8A%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1//image-20240328175541476.png)

如果我们传递了不符合条件的数据，控制台会报错。



#### 单向数据流

data和prop都可以给组件提供数据。

区别：

1、data的数据是自己的，随便改。

2、prop接收的是父组件传递给的数据，不能直接改，要遵循单向数据流。

如果子组件要修改数据，我们要使用`$emit` 通知父组件进行修改，修改之后父组件会继续通过prop将数据传递给子组件，然后子组件接收并渲染。达到修改数据的目的。



### 非父子关系

#### 事件总线

作用：非父子组件之间，进行简易的消息传递（复杂场景可以使用Vuex）

所谓的事件总线，其实就是一个空的Vue实例，这个Vue实例要能被大家都访问到。然后非父子组件之间把这个事件总线当作媒介，进行消息传递。

消息发送的组件触发一个发送消息的事件。消息接收的组件（可以是多个组件）对事件进行监听，来接收传递的消息。

```js
// 在src下定义一个utils文件夹，在文件夹内创建一个eventBus.js
import Vue from 'vue' // 导入vue
const Bus = new Vue() // 创建一个事件总线（空的Vue实例）
export default Bus // 将实例导出，别的组件使用的时候直接导入即可


//组件A：消息发送
<template>
    <div @click="send">
        <div class="box">发送消息</div>
    </div>
</template>
<script>
    import Bus from '../utils/EventBus' // 将我们的事件总线导入

    export default {
        methods:{
            send() {
                Bus.$emit('sendMsg',"这是一个事件总线发布的消息") // 注意这里触发 sendMsg 事件用的是 Bus 对象，
            }
        }
    }
</script>
<style scoped>
    .box {
        width: 100px;
        height: 100px;
        background-color: #000;
        color:#fff
    }
</style>


// 组件B 消息接收
<template>
    <div>
        <p>{{msg}}</p>
    </div>
</template>
<script>
    import Bus from '../utils/EventBus' // 导入事件总线
    export default {
        data() {
            return  {
                msg:""
            }
        },
        created() {
            // 使用 $on 监听 sendMsg 事件，注意这里监听使用的是Bus对象
            Bus.$on("sendMsg",(msg)=>{
                // 回调函数注意使用箭头函数，function函数会导致作用域问题，我们的this.msg无法找到外面的变量
                this.msg = msg
            })
        }
    }
</script>
<style>
div {
    width: 100px;
    height: 100px;
    border: 1px solid #ccc;
}
</style>
```



#### provide-inject

作用：跨层级共享数据 （父组件传递数据之后，不止子组件，所有后代组件都可以访问到）

1、父组件使用provide提供数据

2、子/孙组件inject取值使用

语法：

```js
				provide() {
            return {
                传递的数据
            }
        },
```



> provide传值可以传递简单类型（数字，字符串等），和复杂类型（对象）
>
> 简单类型：非响应式（修改值后，后代组件页面渲染不会自动更新）
> 复杂类型：响应式（修改值后，后代组件页面渲染自动更新，推荐使用，可以将简单类型包装成复杂类型）

```js
// 组件A 导入组件B ， 组件B导入组件C
//组件A
<template>
    <div @click="change">
        <div class="box">修改数据</div>
        <BaseB></BaseB>
    </div>
</template>

<script>
    import BaseB from "./BaseB.vue";
    export default {
        components:{
            BaseB
        },
        data() {
            return {
                msg:"", // 简单类型，非响应式
                obj:{ // 复杂类型，响应式
                    name:""
                }
            }
        },
        provide() { // 向后代组件传递数据
            return {
                msg: this.msg,
                obj: this.obj
            }
        },
        methods:{
            change() {
                this.msg = "123" // 更新之后后代组件不会自动渲染
                this.obj.name = "hh" // 更新之后后代组件会自动渲染
            }
        }
    }
</script>
<style scoped>
    .box {
        width: 100px;
        height: 100px;
        background-color: #000;
        color:#fff
    }
</style>


// 组件B
<template>
    <div>
        <p>子组件：{{msg}} - {{obj.name}}</p>
        <BaseC></BaseC>
    </div>
</template>
<script>
    import BaseC from "./BaseC.vue";
    export default {
        inject:["msg","obj"], // 接收上面传递的数据
        components:{
            BaseC
        }
    }
</script>
<style>
div {
    width: 100px;
    height: 100px;
    border: 1px solid #ccc;
}
</style>


// 组件C
<template>
    <div>
        <p>孙组件{{msg}} - {{obj.name}}</p>
    </div>
</template>
<script>
    export default {
        inject:["msg","obj"] // 接收上面传递的数据
    }
</script>
<style>
div {
    width: 100px;
    height: 100px;
    border: 1px solid #ccc;
}
</style>
```



### v-model的原理

v-model的作用是双向绑定，即我们修改了变量数据，页面会自动渲染，在页面修改了数据，变量也会自动同步这个值。

如果我们自己实现一个v-model的效果，要怎么处理呢？

上面的效果，我们可以拆分为两步来完成：

1、修改变量数据，页面会自动渲染。这一步我们可以使用绑定value属性的方式来实现，我们给输入框绑定一个value属性，属性值就是定义好的变量值。这样就实现了

2、在页面修改值，自动同步变量。这一步我们可以监听输入框的input事件，当事件触发之后，我们就可以手动获取当前元素的值来给变量赋值。

